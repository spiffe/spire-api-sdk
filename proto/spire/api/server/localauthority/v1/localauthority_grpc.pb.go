// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.2
// source: spire/api/server/localauthority/v1/localauthority.proto

package localauthorityv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LocalAuthority_GetJWTAuthorityState_FullMethodName        = "/spire.api.server.localauthority.v1.LocalAuthority/GetJWTAuthorityState"
	LocalAuthority_PrepareJWTAuthority_FullMethodName         = "/spire.api.server.localauthority.v1.LocalAuthority/PrepareJWTAuthority"
	LocalAuthority_ActivateJWTAuthority_FullMethodName        = "/spire.api.server.localauthority.v1.LocalAuthority/ActivateJWTAuthority"
	LocalAuthority_TaintJWTAuthority_FullMethodName           = "/spire.api.server.localauthority.v1.LocalAuthority/TaintJWTAuthority"
	LocalAuthority_RevokeJWTAuthority_FullMethodName          = "/spire.api.server.localauthority.v1.LocalAuthority/RevokeJWTAuthority"
	LocalAuthority_GetX509AuthorityState_FullMethodName       = "/spire.api.server.localauthority.v1.LocalAuthority/GetX509AuthorityState"
	LocalAuthority_PrepareX509Authority_FullMethodName        = "/spire.api.server.localauthority.v1.LocalAuthority/PrepareX509Authority"
	LocalAuthority_ActivateX509Authority_FullMethodName       = "/spire.api.server.localauthority.v1.LocalAuthority/ActivateX509Authority"
	LocalAuthority_TaintX509Authority_FullMethodName          = "/spire.api.server.localauthority.v1.LocalAuthority/TaintX509Authority"
	LocalAuthority_TaintX509UpstreamAuthority_FullMethodName  = "/spire.api.server.localauthority.v1.LocalAuthority/TaintX509UpstreamAuthority"
	LocalAuthority_RevokeX509Authority_FullMethodName         = "/spire.api.server.localauthority.v1.LocalAuthority/RevokeX509Authority"
	LocalAuthority_RevokeX509UpstreamAuthority_FullMethodName = "/spire.api.server.localauthority.v1.LocalAuthority/RevokeX509UpstreamAuthority"
)

// LocalAuthorityClient is the client API for LocalAuthority service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// The LocalAuthority service provides a way to manage the signing keys (and
// related material) of the SPIRE Server exposing it.
type LocalAuthorityClient interface {
	// GetJWTAuthorityState returns the state of all locally configured
	// JWT authorities.
	GetJWTAuthorityState(ctx context.Context, in *GetJWTAuthorityStateRequest, opts ...grpc.CallOption) (*GetJWTAuthorityStateResponse, error)
	// PrepareJWTAuthority prepares a new JWT authority for use by
	// generating a new key and injecting it into the bundle. This action
	// will propagate the new public key cluster-wide.
	PrepareJWTAuthority(ctx context.Context, in *PrepareJWTAuthorityRequest, opts ...grpc.CallOption) (*PrepareJWTAuthorityResponse, error)
	// ActivateJWTAuthority activates a prepared JWT authority for use,
	// which will cause it to be used for all JWT signing operations
	// serviced by this server going forward. If a new JWT authority has
	// not already been prepared, a FailedPrecondition error will be returned.
	ActivateJWTAuthority(ctx context.Context, in *ActivateJWTAuthorityRequest, opts ...grpc.CallOption) (*ActivateJWTAuthorityResponse, error)
	// TaintJWTAuthority marks the previously active JWT authority as
	// being tainted. SPIRE Agents observing an authority to be tainted
	// will perform proactive rotations of any key material related to
	// the tainted authority. The result of this action will be observed
	// cluster-wide.
	// It can receive the Authority ID of an old JWT authority.
	//
	// If a previously active JWT authority does not exist (e.g. if one
	// has been prepared but not activated yet), a FailedPrecondition
	// error will be returned.
	TaintJWTAuthority(ctx context.Context, in *TaintJWTAuthorityRequest, opts ...grpc.CallOption) (*TaintJWTAuthorityResponse, error)
	// RevokeJWTAuthority revokes the previously active JWT authority by
	// removing it from the bundle and propagating this update throughout
	// the cluster.
	// It can receive the Authority ID of an old JWT authority.
	//
	// If a previously active JWT authority does not exist (e.g. if one
	// has been prepared but not activated yet), a FailedPrecondition
	// error will be returned.
	RevokeJWTAuthority(ctx context.Context, in *RevokeJWTAuthorityRequest, opts ...grpc.CallOption) (*RevokeJWTAuthorityResponse, error)
	// GetX509AuthorityState returns the state of all locally configured
	// X.509 authorities.
	GetX509AuthorityState(ctx context.Context, in *GetX509AuthorityStateRequest, opts ...grpc.CallOption) (*GetX509AuthorityStateResponse, error)
	// PrepareX509Authority prepares a new X.509 authority for use by
	// generating a new key and injecting the resulting CA certificate into
	// the bundle. This action will  propagate the new CA cluster-wide.
	PrepareX509Authority(ctx context.Context, in *PrepareX509AuthorityRequest, opts ...grpc.CallOption) (*PrepareX509AuthorityResponse, error)
	// ActivateX509Authority activates a prepared X.509 authority for use,
	// which will cause it to be used for all X.509 signing operations
	// serviced by this server going forward. If a new X.509 authority has
	// not already been prepared, a FailedPrecondition error will be returned.
	ActivateX509Authority(ctx context.Context, in *ActivateX509AuthorityRequest, opts ...grpc.CallOption) (*ActivateX509AuthorityResponse, error)
	// TaintX509Authority marks the previously active X.509 authority as
	// being tainted. SPIRE Agents observing an authority to be tainted
	// will perform proactive rotations of any key material related to
	// the tainted authority. The result of this action will be observed
	// cluster-wide.
	// The X.509 authority to taint is identified using the provided X.509 Subject Key
	//
	// If an upstream authority is configured then local authorities cannot be tainted,
	// and a FailedPrecondition error will be returned.
	//
	// If a previously active X.509 authority does not exist (e.g. if one
	// has been prepared but not activated yet), a FailedPrecondition
	// error will be returned.
	TaintX509Authority(ctx context.Context, in *TaintX509AuthorityRequest, opts ...grpc.CallOption) (*TaintX509AuthorityResponse, error)
	// TaintX509UpstreamAuthority marks the provided upstream authority as
	// being tainted. SPIRE Agents observing a tainted authority
	// will perform proactive rotations of any key material related to
	// the tainted authority. The result of this action will be observed
	// cluster-wide.
	// It is important to change to a new active upstream authority before tainting the old one,
	// since tainting will force the rotation of any bundle that is using
	// the old upstream authority.
	// The X.509 authority to taint is identified using the provided X.509 Subject Key
	// Identifier (or SKID) of the old X.509 authority.
	//
	// If an X.509 upstream authority is not configured, or the identified upstream
	// X.509 authority is active, a FailedPrecondition error will be returned.
	TaintX509UpstreamAuthority(ctx context.Context, in *TaintX509UpstreamAuthorityRequest, opts ...grpc.CallOption) (*TaintX509UpstreamAuthorityResponse, error)
	// RevokeX509Authority revokes the previously active X.509 authority by
	// removing it from the bundle and propagating this update throughout
	// the cluster.
	// It can receive the public key of an old X.509 authority.
	//
	// If a previously active X.509 authority does not exist (e.g. if one
	// has been prepared but not activated yet), a FailedPrecondition
	// error will be returned.
	RevokeX509Authority(ctx context.Context, in *RevokeX509AuthorityRequest, opts ...grpc.CallOption) (*RevokeX509AuthorityResponse, error)
	// RevokeX509UpstreamAuthority revokes the previously active X.509 upstream authority by
	// removing it from the bundle and propagating this update throughout
	// the cluster.
	// The X.509 authority to revoke is identified using the provided subject key ID of
	// the authority's CA certificate.
	//
	// If a previously active X.509 upstream authority does not exist, a FailedPrecondition
	// error will be returned.
	RevokeX509UpstreamAuthority(ctx context.Context, in *RevokeX509UpstreamAuthorityRequest, opts ...grpc.CallOption) (*RevokeX509UpstreamAuthorityResponse, error)
}

type localAuthorityClient struct {
	cc grpc.ClientConnInterface
}

func NewLocalAuthorityClient(cc grpc.ClientConnInterface) LocalAuthorityClient {
	return &localAuthorityClient{cc}
}

func (c *localAuthorityClient) GetJWTAuthorityState(ctx context.Context, in *GetJWTAuthorityStateRequest, opts ...grpc.CallOption) (*GetJWTAuthorityStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetJWTAuthorityStateResponse)
	err := c.cc.Invoke(ctx, LocalAuthority_GetJWTAuthorityState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localAuthorityClient) PrepareJWTAuthority(ctx context.Context, in *PrepareJWTAuthorityRequest, opts ...grpc.CallOption) (*PrepareJWTAuthorityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PrepareJWTAuthorityResponse)
	err := c.cc.Invoke(ctx, LocalAuthority_PrepareJWTAuthority_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localAuthorityClient) ActivateJWTAuthority(ctx context.Context, in *ActivateJWTAuthorityRequest, opts ...grpc.CallOption) (*ActivateJWTAuthorityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActivateJWTAuthorityResponse)
	err := c.cc.Invoke(ctx, LocalAuthority_ActivateJWTAuthority_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localAuthorityClient) TaintJWTAuthority(ctx context.Context, in *TaintJWTAuthorityRequest, opts ...grpc.CallOption) (*TaintJWTAuthorityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaintJWTAuthorityResponse)
	err := c.cc.Invoke(ctx, LocalAuthority_TaintJWTAuthority_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localAuthorityClient) RevokeJWTAuthority(ctx context.Context, in *RevokeJWTAuthorityRequest, opts ...grpc.CallOption) (*RevokeJWTAuthorityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeJWTAuthorityResponse)
	err := c.cc.Invoke(ctx, LocalAuthority_RevokeJWTAuthority_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localAuthorityClient) GetX509AuthorityState(ctx context.Context, in *GetX509AuthorityStateRequest, opts ...grpc.CallOption) (*GetX509AuthorityStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetX509AuthorityStateResponse)
	err := c.cc.Invoke(ctx, LocalAuthority_GetX509AuthorityState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localAuthorityClient) PrepareX509Authority(ctx context.Context, in *PrepareX509AuthorityRequest, opts ...grpc.CallOption) (*PrepareX509AuthorityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PrepareX509AuthorityResponse)
	err := c.cc.Invoke(ctx, LocalAuthority_PrepareX509Authority_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localAuthorityClient) ActivateX509Authority(ctx context.Context, in *ActivateX509AuthorityRequest, opts ...grpc.CallOption) (*ActivateX509AuthorityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActivateX509AuthorityResponse)
	err := c.cc.Invoke(ctx, LocalAuthority_ActivateX509Authority_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localAuthorityClient) TaintX509Authority(ctx context.Context, in *TaintX509AuthorityRequest, opts ...grpc.CallOption) (*TaintX509AuthorityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaintX509AuthorityResponse)
	err := c.cc.Invoke(ctx, LocalAuthority_TaintX509Authority_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localAuthorityClient) TaintX509UpstreamAuthority(ctx context.Context, in *TaintX509UpstreamAuthorityRequest, opts ...grpc.CallOption) (*TaintX509UpstreamAuthorityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaintX509UpstreamAuthorityResponse)
	err := c.cc.Invoke(ctx, LocalAuthority_TaintX509UpstreamAuthority_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localAuthorityClient) RevokeX509Authority(ctx context.Context, in *RevokeX509AuthorityRequest, opts ...grpc.CallOption) (*RevokeX509AuthorityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeX509AuthorityResponse)
	err := c.cc.Invoke(ctx, LocalAuthority_RevokeX509Authority_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *localAuthorityClient) RevokeX509UpstreamAuthority(ctx context.Context, in *RevokeX509UpstreamAuthorityRequest, opts ...grpc.CallOption) (*RevokeX509UpstreamAuthorityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeX509UpstreamAuthorityResponse)
	err := c.cc.Invoke(ctx, LocalAuthority_RevokeX509UpstreamAuthority_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LocalAuthorityServer is the server API for LocalAuthority service.
// All implementations must embed UnimplementedLocalAuthorityServer
// for forward compatibility.
//
// The LocalAuthority service provides a way to manage the signing keys (and
// related material) of the SPIRE Server exposing it.
type LocalAuthorityServer interface {
	// GetJWTAuthorityState returns the state of all locally configured
	// JWT authorities.
	GetJWTAuthorityState(context.Context, *GetJWTAuthorityStateRequest) (*GetJWTAuthorityStateResponse, error)
	// PrepareJWTAuthority prepares a new JWT authority for use by
	// generating a new key and injecting it into the bundle. This action
	// will propagate the new public key cluster-wide.
	PrepareJWTAuthority(context.Context, *PrepareJWTAuthorityRequest) (*PrepareJWTAuthorityResponse, error)
	// ActivateJWTAuthority activates a prepared JWT authority for use,
	// which will cause it to be used for all JWT signing operations
	// serviced by this server going forward. If a new JWT authority has
	// not already been prepared, a FailedPrecondition error will be returned.
	ActivateJWTAuthority(context.Context, *ActivateJWTAuthorityRequest) (*ActivateJWTAuthorityResponse, error)
	// TaintJWTAuthority marks the previously active JWT authority as
	// being tainted. SPIRE Agents observing an authority to be tainted
	// will perform proactive rotations of any key material related to
	// the tainted authority. The result of this action will be observed
	// cluster-wide.
	// It can receive the Authority ID of an old JWT authority.
	//
	// If a previously active JWT authority does not exist (e.g. if one
	// has been prepared but not activated yet), a FailedPrecondition
	// error will be returned.
	TaintJWTAuthority(context.Context, *TaintJWTAuthorityRequest) (*TaintJWTAuthorityResponse, error)
	// RevokeJWTAuthority revokes the previously active JWT authority by
	// removing it from the bundle and propagating this update throughout
	// the cluster.
	// It can receive the Authority ID of an old JWT authority.
	//
	// If a previously active JWT authority does not exist (e.g. if one
	// has been prepared but not activated yet), a FailedPrecondition
	// error will be returned.
	RevokeJWTAuthority(context.Context, *RevokeJWTAuthorityRequest) (*RevokeJWTAuthorityResponse, error)
	// GetX509AuthorityState returns the state of all locally configured
	// X.509 authorities.
	GetX509AuthorityState(context.Context, *GetX509AuthorityStateRequest) (*GetX509AuthorityStateResponse, error)
	// PrepareX509Authority prepares a new X.509 authority for use by
	// generating a new key and injecting the resulting CA certificate into
	// the bundle. This action will  propagate the new CA cluster-wide.
	PrepareX509Authority(context.Context, *PrepareX509AuthorityRequest) (*PrepareX509AuthorityResponse, error)
	// ActivateX509Authority activates a prepared X.509 authority for use,
	// which will cause it to be used for all X.509 signing operations
	// serviced by this server going forward. If a new X.509 authority has
	// not already been prepared, a FailedPrecondition error will be returned.
	ActivateX509Authority(context.Context, *ActivateX509AuthorityRequest) (*ActivateX509AuthorityResponse, error)
	// TaintX509Authority marks the previously active X.509 authority as
	// being tainted. SPIRE Agents observing an authority to be tainted
	// will perform proactive rotations of any key material related to
	// the tainted authority. The result of this action will be observed
	// cluster-wide.
	// The X.509 authority to taint is identified using the provided X.509 Subject Key
	//
	// If an upstream authority is configured then local authorities cannot be tainted,
	// and a FailedPrecondition error will be returned.
	//
	// If a previously active X.509 authority does not exist (e.g. if one
	// has been prepared but not activated yet), a FailedPrecondition
	// error will be returned.
	TaintX509Authority(context.Context, *TaintX509AuthorityRequest) (*TaintX509AuthorityResponse, error)
	// TaintX509UpstreamAuthority marks the provided upstream authority as
	// being tainted. SPIRE Agents observing a tainted authority
	// will perform proactive rotations of any key material related to
	// the tainted authority. The result of this action will be observed
	// cluster-wide.
	// It is important to change to a new active upstream authority before tainting the old one,
	// since tainting will force the rotation of any bundle that is using
	// the old upstream authority.
	// The X.509 authority to taint is identified using the provided X.509 Subject Key
	// Identifier (or SKID) of the old X.509 authority.
	//
	// If an X.509 upstream authority is not configured, or the identified upstream
	// X.509 authority is active, a FailedPrecondition error will be returned.
	TaintX509UpstreamAuthority(context.Context, *TaintX509UpstreamAuthorityRequest) (*TaintX509UpstreamAuthorityResponse, error)
	// RevokeX509Authority revokes the previously active X.509 authority by
	// removing it from the bundle and propagating this update throughout
	// the cluster.
	// It can receive the public key of an old X.509 authority.
	//
	// If a previously active X.509 authority does not exist (e.g. if one
	// has been prepared but not activated yet), a FailedPrecondition
	// error will be returned.
	RevokeX509Authority(context.Context, *RevokeX509AuthorityRequest) (*RevokeX509AuthorityResponse, error)
	// RevokeX509UpstreamAuthority revokes the previously active X.509 upstream authority by
	// removing it from the bundle and propagating this update throughout
	// the cluster.
	// The X.509 authority to revoke is identified using the provided subject key ID of
	// the authority's CA certificate.
	//
	// If a previously active X.509 upstream authority does not exist, a FailedPrecondition
	// error will be returned.
	RevokeX509UpstreamAuthority(context.Context, *RevokeX509UpstreamAuthorityRequest) (*RevokeX509UpstreamAuthorityResponse, error)
	mustEmbedUnimplementedLocalAuthorityServer()
}

// UnimplementedLocalAuthorityServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLocalAuthorityServer struct{}

func (UnimplementedLocalAuthorityServer) GetJWTAuthorityState(context.Context, *GetJWTAuthorityStateRequest) (*GetJWTAuthorityStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJWTAuthorityState not implemented")
}
func (UnimplementedLocalAuthorityServer) PrepareJWTAuthority(context.Context, *PrepareJWTAuthorityRequest) (*PrepareJWTAuthorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareJWTAuthority not implemented")
}
func (UnimplementedLocalAuthorityServer) ActivateJWTAuthority(context.Context, *ActivateJWTAuthorityRequest) (*ActivateJWTAuthorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateJWTAuthority not implemented")
}
func (UnimplementedLocalAuthorityServer) TaintJWTAuthority(context.Context, *TaintJWTAuthorityRequest) (*TaintJWTAuthorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaintJWTAuthority not implemented")
}
func (UnimplementedLocalAuthorityServer) RevokeJWTAuthority(context.Context, *RevokeJWTAuthorityRequest) (*RevokeJWTAuthorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeJWTAuthority not implemented")
}
func (UnimplementedLocalAuthorityServer) GetX509AuthorityState(context.Context, *GetX509AuthorityStateRequest) (*GetX509AuthorityStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetX509AuthorityState not implemented")
}
func (UnimplementedLocalAuthorityServer) PrepareX509Authority(context.Context, *PrepareX509AuthorityRequest) (*PrepareX509AuthorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareX509Authority not implemented")
}
func (UnimplementedLocalAuthorityServer) ActivateX509Authority(context.Context, *ActivateX509AuthorityRequest) (*ActivateX509AuthorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateX509Authority not implemented")
}
func (UnimplementedLocalAuthorityServer) TaintX509Authority(context.Context, *TaintX509AuthorityRequest) (*TaintX509AuthorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaintX509Authority not implemented")
}
func (UnimplementedLocalAuthorityServer) TaintX509UpstreamAuthority(context.Context, *TaintX509UpstreamAuthorityRequest) (*TaintX509UpstreamAuthorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaintX509UpstreamAuthority not implemented")
}
func (UnimplementedLocalAuthorityServer) RevokeX509Authority(context.Context, *RevokeX509AuthorityRequest) (*RevokeX509AuthorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeX509Authority not implemented")
}
func (UnimplementedLocalAuthorityServer) RevokeX509UpstreamAuthority(context.Context, *RevokeX509UpstreamAuthorityRequest) (*RevokeX509UpstreamAuthorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeX509UpstreamAuthority not implemented")
}
func (UnimplementedLocalAuthorityServer) mustEmbedUnimplementedLocalAuthorityServer() {}
func (UnimplementedLocalAuthorityServer) testEmbeddedByValue()                        {}

// UnsafeLocalAuthorityServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LocalAuthorityServer will
// result in compilation errors.
type UnsafeLocalAuthorityServer interface {
	mustEmbedUnimplementedLocalAuthorityServer()
}

func RegisterLocalAuthorityServer(s grpc.ServiceRegistrar, srv LocalAuthorityServer) {
	// If the following call pancis, it indicates UnimplementedLocalAuthorityServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LocalAuthority_ServiceDesc, srv)
}

func _LocalAuthority_GetJWTAuthorityState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJWTAuthorityStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalAuthorityServer).GetJWTAuthorityState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalAuthority_GetJWTAuthorityState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalAuthorityServer).GetJWTAuthorityState(ctx, req.(*GetJWTAuthorityStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalAuthority_PrepareJWTAuthority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareJWTAuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalAuthorityServer).PrepareJWTAuthority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalAuthority_PrepareJWTAuthority_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalAuthorityServer).PrepareJWTAuthority(ctx, req.(*PrepareJWTAuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalAuthority_ActivateJWTAuthority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivateJWTAuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalAuthorityServer).ActivateJWTAuthority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalAuthority_ActivateJWTAuthority_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalAuthorityServer).ActivateJWTAuthority(ctx, req.(*ActivateJWTAuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalAuthority_TaintJWTAuthority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaintJWTAuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalAuthorityServer).TaintJWTAuthority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalAuthority_TaintJWTAuthority_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalAuthorityServer).TaintJWTAuthority(ctx, req.(*TaintJWTAuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalAuthority_RevokeJWTAuthority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeJWTAuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalAuthorityServer).RevokeJWTAuthority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalAuthority_RevokeJWTAuthority_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalAuthorityServer).RevokeJWTAuthority(ctx, req.(*RevokeJWTAuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalAuthority_GetX509AuthorityState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetX509AuthorityStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalAuthorityServer).GetX509AuthorityState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalAuthority_GetX509AuthorityState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalAuthorityServer).GetX509AuthorityState(ctx, req.(*GetX509AuthorityStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalAuthority_PrepareX509Authority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareX509AuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalAuthorityServer).PrepareX509Authority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalAuthority_PrepareX509Authority_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalAuthorityServer).PrepareX509Authority(ctx, req.(*PrepareX509AuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalAuthority_ActivateX509Authority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivateX509AuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalAuthorityServer).ActivateX509Authority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalAuthority_ActivateX509Authority_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalAuthorityServer).ActivateX509Authority(ctx, req.(*ActivateX509AuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalAuthority_TaintX509Authority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaintX509AuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalAuthorityServer).TaintX509Authority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalAuthority_TaintX509Authority_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalAuthorityServer).TaintX509Authority(ctx, req.(*TaintX509AuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalAuthority_TaintX509UpstreamAuthority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaintX509UpstreamAuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalAuthorityServer).TaintX509UpstreamAuthority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalAuthority_TaintX509UpstreamAuthority_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalAuthorityServer).TaintX509UpstreamAuthority(ctx, req.(*TaintX509UpstreamAuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalAuthority_RevokeX509Authority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeX509AuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalAuthorityServer).RevokeX509Authority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalAuthority_RevokeX509Authority_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalAuthorityServer).RevokeX509Authority(ctx, req.(*RevokeX509AuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LocalAuthority_RevokeX509UpstreamAuthority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeX509UpstreamAuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocalAuthorityServer).RevokeX509UpstreamAuthority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LocalAuthority_RevokeX509UpstreamAuthority_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocalAuthorityServer).RevokeX509UpstreamAuthority(ctx, req.(*RevokeX509UpstreamAuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LocalAuthority_ServiceDesc is the grpc.ServiceDesc for LocalAuthority service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LocalAuthority_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "spire.api.server.localauthority.v1.LocalAuthority",
	HandlerType: (*LocalAuthorityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetJWTAuthorityState",
			Handler:    _LocalAuthority_GetJWTAuthorityState_Handler,
		},
		{
			MethodName: "PrepareJWTAuthority",
			Handler:    _LocalAuthority_PrepareJWTAuthority_Handler,
		},
		{
			MethodName: "ActivateJWTAuthority",
			Handler:    _LocalAuthority_ActivateJWTAuthority_Handler,
		},
		{
			MethodName: "TaintJWTAuthority",
			Handler:    _LocalAuthority_TaintJWTAuthority_Handler,
		},
		{
			MethodName: "RevokeJWTAuthority",
			Handler:    _LocalAuthority_RevokeJWTAuthority_Handler,
		},
		{
			MethodName: "GetX509AuthorityState",
			Handler:    _LocalAuthority_GetX509AuthorityState_Handler,
		},
		{
			MethodName: "PrepareX509Authority",
			Handler:    _LocalAuthority_PrepareX509Authority_Handler,
		},
		{
			MethodName: "ActivateX509Authority",
			Handler:    _LocalAuthority_ActivateX509Authority_Handler,
		},
		{
			MethodName: "TaintX509Authority",
			Handler:    _LocalAuthority_TaintX509Authority_Handler,
		},
		{
			MethodName: "TaintX509UpstreamAuthority",
			Handler:    _LocalAuthority_TaintX509UpstreamAuthority_Handler,
		},
		{
			MethodName: "RevokeX509Authority",
			Handler:    _LocalAuthority_RevokeX509Authority_Handler,
		},
		{
			MethodName: "RevokeX509UpstreamAuthority",
			Handler:    _LocalAuthority_RevokeX509UpstreamAuthority_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "spire/api/server/localauthority/v1/localauthority.proto",
}
